package genimports

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestGenerateConstantsFile(t *testing.T) {
	tests := []struct {
		name     string
		pkgName  string
		service  string
		resource string
		wantPkg  string
		wantPath string
	}{
		{
			name:     "simple package",
			pkgName:  "instances",
			service:  "ec2",
			resource: "instances",
			wantPkg:  "package instances",
			wantPath: `const ServiceResourcePath = "ec2/instances"`,
		},
		{
			name:     "hyphenated resource",
			pkgName:  "trainingjobs",
			service:  "sagemaker",
			resource: "training-jobs",
			wantPkg:  "package trainingjobs",
			wantPath: `const ServiceResourcePath = "sagemaker/training-jobs"`,
		},
		{
			name:     "hyphenated service and resource",
			pkgName:  "knowledgebases",
			service:  "bedrock-agent",
			resource: "knowledge-bases",
			wantPkg:  "package knowledgebases",
			wantPath: `const ServiceResourcePath = "bedrock-agent/knowledge-bases"`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := string(GenerateConstantsFile(tt.pkgName, tt.service, tt.resource))

			if !strings.HasPrefix(got, "// Code generated by go generate; DO NOT EDIT.") {
				t.Error("missing generated code header")
			}
			if !strings.Contains(got, "// To regenerate: task gen-imports") {
				t.Error("missing regenerate instruction")
			}
			if !strings.Contains(got, tt.wantPkg) {
				t.Errorf("want package %q in output", tt.wantPkg)
			}
			if !strings.Contains(got, tt.wantPath) {
				t.Errorf("want constant %q in output", tt.wantPath)
			}
			if !strings.Contains(got, "// ServiceResourcePath is the canonical path") {
				t.Error("missing doc comment for constant")
			}
		})
	}
}

func TestGetServiceDisplayName(t *testing.T) {
	tests := []struct {
		service string
		want    string
	}{
		{"ec2", "EC2"},
		{"s3", "S3"},
		{"lambda", "Lambda"},
		{"bedrock-agent", "Bedrock Agent"},
		{"cloudformation", "CloudFormation"},
		{"unknown", "Unknown"},
	}

	for _, tt := range tests {
		t.Run(tt.service, func(t *testing.T) {
			got := GetServiceDisplayName(tt.service)
			if got != tt.want {
				t.Errorf("GetServiceDisplayName(%q) = %q, want %q", tt.service, got, tt.want)
			}
		})
	}
}

func TestGroupByService(t *testing.T) {
	packages := []string{
		"github.com/clawscli/claws/custom/ec2/instances",
		"github.com/clawscli/claws/custom/ec2/volumes",
		"github.com/clawscli/claws/custom/s3/buckets",
		"github.com/clawscli/claws/custom/lambda/functions",
	}

	grouped := GroupByService(packages)

	if len(grouped["ec2"]) != 2 {
		t.Errorf("ec2 should have 2 packages, got %d", len(grouped["ec2"]))
	}
	if len(grouped["s3"]) != 1 {
		t.Errorf("s3 should have 1 package, got %d", len(grouped["s3"]))
	}
	if len(grouped["lambda"]) != 1 {
		t.Errorf("lambda should have 1 package, got %d", len(grouped["lambda"]))
	}
}

func TestGetPackageInfo(t *testing.T) {
	tests := []struct {
		name       string
		importPath string
		wantSvc    string
		wantRes    string
		wantDir    string
	}{
		{
			name:       "simple",
			importPath: "github.com/clawscli/claws/custom/ec2/instances",
			wantSvc:    "ec2",
			wantRes:    "instances",
			wantDir:    "custom/ec2/instances",
		},
		{
			name:       "hyphenated resource",
			importPath: "github.com/clawscli/claws/custom/sagemaker/training-jobs",
			wantSvc:    "sagemaker",
			wantRes:    "training-jobs",
			wantDir:    "custom/sagemaker/training-jobs",
		},
		{
			name:       "hyphenated service",
			importPath: "github.com/clawscli/claws/custom/bedrock-agent/agents",
			wantSvc:    "bedrock-agent",
			wantRes:    "agents",
			wantDir:    "custom/bedrock-agent/agents",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			info := GetPackageInfo("", tt.importPath)

			if info.Service != tt.wantSvc {
				t.Errorf("Service = %q, want %q", info.Service, tt.wantSvc)
			}
			if info.Resource != tt.wantRes {
				t.Errorf("Resource = %q, want %q", info.Resource, tt.wantRes)
			}
			if info.DirPath != tt.wantDir {
				t.Errorf("DirPath = %q, want %q", info.DirPath, tt.wantDir)
			}
			if info.ImportPath != tt.importPath {
				t.Errorf("ImportPath = %q, want %q", info.ImportPath, tt.importPath)
			}
		})
	}
}

func TestGetPackageInfoFallbackPackageName(t *testing.T) {
	info := GetPackageInfo("", "github.com/clawscli/claws/custom/sagemaker/training-jobs")

	if info.PackageName != "trainingjobs" {
		t.Errorf("PackageName = %q, want %q", info.PackageName, "trainingjobs")
	}
}

func TestFindRegisterPackages(t *testing.T) {
	t.Run("finds register.go files", func(t *testing.T) {
		tmpDir := t.TempDir()
		svc1Dir := filepath.Join(tmpDir, "custom", "ec2", "instances")
		svc2Dir := filepath.Join(tmpDir, "custom", "s3", "buckets")

		if err := os.MkdirAll(svc1Dir, 0o755); err != nil {
			t.Fatal(err)
		}
		if err := os.MkdirAll(svc2Dir, 0o755); err != nil {
			t.Fatal(err)
		}
		if err := os.WriteFile(filepath.Join(svc1Dir, "register.go"), []byte("package instances\n"), 0o644); err != nil {
			t.Fatal(err)
		}
		if err := os.WriteFile(filepath.Join(svc2Dir, "register.go"), []byte("package buckets\n"), 0o644); err != nil {
			t.Fatal(err)
		}

		packages, err := FindRegisterPackages(tmpDir)
		if err != nil {
			t.Fatalf("FindRegisterPackages() error = %v", err)
		}

		if len(packages) != 2 {
			t.Errorf("FindRegisterPackages() returned %d packages, want 2", len(packages))
		}
		if len(packages) >= 2 && packages[0] > packages[1] {
			t.Error("FindRegisterPackages() packages not sorted")
		}
	})

	t.Run("returns error for missing custom dir", func(t *testing.T) {
		tmpDir := t.TempDir()

		_, err := FindRegisterPackages(tmpDir)
		if err == nil {
			t.Error("FindRegisterPackages() expected error for missing custom dir")
		}
	})

	t.Run("ignores non-register.go files", func(t *testing.T) {
		tmpDir := t.TempDir()
		svcDir := filepath.Join(tmpDir, "custom", "ec2", "instances")
		if err := os.MkdirAll(svcDir, 0o755); err != nil {
			t.Fatal(err)
		}
		if err := os.WriteFile(filepath.Join(svcDir, "dao.go"), []byte("package instances\n"), 0o644); err != nil {
			t.Fatal(err)
		}
		if err := os.WriteFile(filepath.Join(svcDir, "render.go"), []byte("package instances\n"), 0o644); err != nil {
			t.Fatal(err)
		}

		packages, err := FindRegisterPackages(tmpDir)
		if err != nil {
			t.Fatalf("FindRegisterPackages() error = %v", err)
		}

		if len(packages) != 0 {
			t.Errorf("FindRegisterPackages() returned %d packages, want 0", len(packages))
		}
	})

	t.Run("handles hyphenated directories", func(t *testing.T) {
		tmpDir := t.TempDir()
		svcDir := filepath.Join(tmpDir, "custom", "bedrock-agent", "knowledge-bases")
		if err := os.MkdirAll(svcDir, 0o755); err != nil {
			t.Fatal(err)
		}
		if err := os.WriteFile(filepath.Join(svcDir, "register.go"), []byte("package knowledgebases\n"), 0o644); err != nil {
			t.Fatal(err)
		}

		packages, err := FindRegisterPackages(tmpDir)
		if err != nil {
			t.Fatalf("FindRegisterPackages() error = %v", err)
		}

		if len(packages) != 1 {
			t.Fatalf("FindRegisterPackages() returned %d packages, want 1", len(packages))
		}

		want := ModulePrefix + "/custom/bedrock-agent/knowledge-bases"
		if packages[0] != want {
			t.Errorf("FindRegisterPackages()[0] = %q, want %q", packages[0], want)
		}
	})
}

func TestGetProjectRoot(t *testing.T) {
	t.Run("returns current dir when not in cmd/claws", func(t *testing.T) {
		origWd, err := os.Getwd()
		if err != nil {
			t.Fatal(err)
		}
		defer func() { _ = os.Chdir(origWd) }()

		tmpDir := t.TempDir()
		if err := os.Chdir(tmpDir); err != nil {
			t.Fatal(err)
		}

		root, err := GetProjectRoot()
		if err != nil {
			t.Fatalf("GetProjectRoot() error = %v", err)
		}

		if root != tmpDir {
			t.Errorf("GetProjectRoot() = %q, want %q", root, tmpDir)
		}
	})

	t.Run("goes up two levels from cmd/claws", func(t *testing.T) {
		origWd, err := os.Getwd()
		if err != nil {
			t.Fatal(err)
		}
		defer func() { _ = os.Chdir(origWd) }()

		tmpDir := t.TempDir()
		cmdClawsDir := filepath.Join(tmpDir, "cmd", "claws")
		if err := os.MkdirAll(cmdClawsDir, 0o755); err != nil {
			t.Fatal(err)
		}
		if err := os.Chdir(cmdClawsDir); err != nil {
			t.Fatal(err)
		}

		root, err := GetProjectRoot()
		if err != nil {
			t.Fatalf("GetProjectRoot() error = %v", err)
		}

		expected := filepath.Join(cmdClawsDir, "..", "..")
		if root != expected {
			t.Errorf("GetProjectRoot() = %q, want %q", root, expected)
		}
	})
}

func TestReadPackageName(t *testing.T) {
	t.Run("reads package name from file", func(t *testing.T) {
		tmpDir := t.TempDir()
		filePath := filepath.Join(tmpDir, "test.go")
		content := "package mypackage\n\nfunc main() {}\n"
		if err := os.WriteFile(filePath, []byte(content), 0o644); err != nil {
			t.Fatal(err)
		}

		got := readPackageName(filePath)
		if got != "mypackage" {
			t.Errorf("readPackageName() = %q, want %q", got, "mypackage")
		}
	})

	t.Run("returns empty string for missing file", func(t *testing.T) {
		got := readPackageName("/nonexistent/path/file.go")
		if got != "" {
			t.Errorf("readPackageName() = %q, want empty string", got)
		}
	})

	t.Run("returns empty string for file without package", func(t *testing.T) {
		tmpDir := t.TempDir()
		filePath := filepath.Join(tmpDir, "test.go")
		content := "func main() {}\n"
		if err := os.WriteFile(filePath, []byte(content), 0o644); err != nil {
			t.Fatal(err)
		}

		got := readPackageName(filePath)
		if got != "" {
			t.Errorf("readPackageName() = %q, want empty string", got)
		}
	})

	t.Run("handles package with trailing content", func(t *testing.T) {
		tmpDir := t.TempDir()
		filePath := filepath.Join(tmpDir, "test.go")
		content := "package main // comment\n"
		if err := os.WriteFile(filePath, []byte(content), 0o644); err != nil {
			t.Fatal(err)
		}

		got := readPackageName(filePath)
		if got != "main // comment" {
			t.Errorf("readPackageName() = %q, want %q", got, "main // comment")
		}
	})

	t.Run("reads empty file", func(t *testing.T) {
		tmpDir := t.TempDir()
		filePath := filepath.Join(tmpDir, "empty.go")
		if err := os.WriteFile(filePath, []byte(""), 0o644); err != nil {
			t.Fatal(err)
		}

		got := readPackageName(filePath)
		if got != "" {
			t.Errorf("readPackageName() = %q, want empty string", got)
		}
	})
}

func TestGetPackageInfoWithRealFile(t *testing.T) {
	tmpDir := t.TempDir()
	pkgDir := filepath.Join(tmpDir, "custom", "ec2", "instances")
	if err := os.MkdirAll(pkgDir, 0o755); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(pkgDir, "register.go"), []byte("package instances\n"), 0o644); err != nil {
		t.Fatal(err)
	}

	info := GetPackageInfo(tmpDir, "github.com/clawscli/claws/custom/ec2/instances")

	if info.PackageName != "instances" {
		t.Errorf("PackageName = %q, want %q", info.PackageName, "instances")
	}
	if info.Service != "ec2" {
		t.Errorf("Service = %q, want %q", info.Service, "ec2")
	}
	if info.Resource != "instances" {
		t.Errorf("Resource = %q, want %q", info.Resource, "instances")
	}
}
